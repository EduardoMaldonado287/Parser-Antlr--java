package matrixL;

import java.awt.Color;
import javax.swing.JFileChooser;
import javax.swing.*;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.io.*;  
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyleContext;
import javax.swing.text.Utilities;

/**
 *
 * @author eduar, Fernando Cabrera
 */
public class MyMatrixL_GUI extends javax.swing.JFrame {
    private final JFileChooser fc;
    private final String route;

    /**
     * Creates new form MyMatrixL_GUI
     */
    public MyMatrixL_GUI() {
        this.fc = new JFileChooser();        
        initComponents();
        this.pack();
        this.setLocationRelativeTo(null);
        this.setVisible(true); 
        this.route = System.getProperty("user.home");
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        openFileBtn = new javax.swing.JButton();
        saveFileBtn = new javax.swing.JButton();
        runBtn = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        resultData = new javax.swing.JTextArea();
        jScrollPane1 = new javax.swing.JScrollPane();
        txtData = new javax.swing.JTextPane();
        cursorPositionText = new javax.swing.JTextField();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        openFileBtn.setText("Open File");
        openFileBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                openFileBtnActionPerformed(evt);
            }
        });

        saveFileBtn.setText("Save File");
        saveFileBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveFileBtnActionPerformed(evt);
            }
        });

        runBtn.setText("Run");
        runBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                runBtnActionPerformed(evt);
            }
        });

        jLabel1.setText("RESULTADO:");

        resultData.setColumns(20);
        resultData.setRows(5);
        jScrollPane2.setViewportView(resultData);

        txtData.addCaretListener(new javax.swing.event.CaretListener() {
            public void caretUpdate(javax.swing.event.CaretEvent evt) {
                txtDataCaretUpdate(evt);
            }
        });
        txtData.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                txtDataMouseClicked(evt);
            }
        });
        txtData.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                txtDataPropertyChange(evt);
            }
        });
        txtData.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                txtDataKeyReleased(evt);
            }
        });
        jScrollPane1.setViewportView(txtData);

        cursorPositionText.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cursorPositionTextActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(cursorPositionText, javax.swing.GroupLayout.PREFERRED_SIZE, 773, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addGap(19, 19, 19)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jScrollPane1)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 775, Short.MAX_VALUE)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(openFileBtn)
                                .addGap(18, 18, 18)
                                .addComponent(saveFileBtn)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(runBtn))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(6, 6, 6)
                                .addComponent(jLabel1)))))
                .addContainerGap(19, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(openFileBtn)
                    .addComponent(saveFileBtn)
                    .addComponent(runBtn))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 385, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(cursorPositionText, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(3, 3, 3)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 130, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(19, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    
    private void openFileBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_openFileBtnActionPerformed
        int result = fc.showOpenDialog(this);
        if (result == JFileChooser.APPROVE_OPTION)
        {
            try {
                BufferedReader br = new BufferedReader(new FileReader(fc.getSelectedFile().getPath()));
                
                String line = "";
                String s = "";
                
                while ((line = br.readLine()) != null)
                {
                    s+= line;
                }
                txtData.setText(s);
                
                if (br != null)
                    br.close();
                
            } catch (FileNotFoundException ex) {
                Logger.getLogger(MyMatrixL_GUI.class.getName()).log(Level.SEVERE, null, ex);
            } catch (IOException ex) {
                Logger.getLogger(MyMatrixL_GUI.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }//GEN-LAST:event_openFileBtnActionPerformed

    private void saveFileBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveFileBtnActionPerformed
        // TODO add your handling code here:
        int result = fc.showSaveDialog(this);
        
        if (result == JFileChooser.APPROVE_OPTION)
        {
            File f = fc.getSelectedFile();

            try {
                FileWriter fw = new FileWriter(f);
                String text = txtData.getText();
                fw.write(text);
                fw.close();
            } catch (IOException ex) {
                Logger.getLogger(MyMatrixL_GUI.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }//GEN-LAST:event_saveFileBtnActionPerformed

    private void runBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_runBtnActionPerformed
        
        /*
            Al momento de dar run, se manda a ejecutar el archivo main que
            Tiene todos los procesos de la gramática
        */
        
        compileMain();
        
        String errorData = getErrorData();
        
        if (errorData.length() > 0)
        {
            System.out.println(errorData.length());
            resultData.setForeground(Color.red);
            resultData.setText("");
            resultData.append("UNABLE TO RUN FILE DUE TO SYNTAX ERRORS:\n");
            resultData.append(errorData);
        }
        else
        {
            resultData.setForeground(Color.black);
            result_data();
        }
    }//GEN-LAST:event_runBtnActionPerformed
    
    public void compileMain()
    {
        /*
            Aquí se manda a ejecutar todo el proyecto (package matrixL)
            Cuando ocurre esto el arhivo main crea un archivo java que a su vez
            crea un archivo de texto con los resultados y otro archivo con los 
            errores en el caso de que exista alguno.
        */
        String userDir = System.getProperty("user.dir");
        String command1 = "java -jar \"C:\\Users\\eduar\\OneDrive - Instituto Tecnologico y de Estudios Superiores de Monterrey\\OneDrive\\Documentos\\NetBeansProjects\\MyMatrixL\\dist\\MyMatrixL.jar\"";
        String command2 = "java -jar \"" + userDir + "\\dist" + "\\MyMatrixL.jar\"";        
        try {
            Process pro;
            pro = Runtime.getRuntime().exec(command1);
        } catch (IOException ex) {
            Logger.getLogger(MyMatrixL_GUI.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    
    public void result_data() 
    {
        try {
            /*
                Las siguientes 7 líneas de codigo nos sirven para comprobar si 
                el archivo java tiene contenido, si no lo tiene es porque el 
                archivo de extensión matL tiene algún error, de ser así se 
                elimina el contenido existene del archivo "myMatrixL_Java.java"
                para que no se imprima algún resultado en el cuadro de resultados
            */
            BufferedReader javaFile = new BufferedReader(new FileReader(route + "/myMatrixL_Java.java"));
            if(javaFile.readLine() == null)
            {
                FileWriter results_matL = new FileWriter(route +"/results_matL.txt");
                results_matL.write("");
                results_matL.close();
            }
          
            // Se lee el archivo results_matL.txt y se muestra gráficamente en el ide
            BufferedReader br = new BufferedReader(new FileReader(route + "/results_matL.txt"));
            String line = "";
            String s = "";

            while ((line = br.readLine()) != null)
            {
                s+= line + "\n";
            }
//            resultData.setText(s);

            if (br != null)
                br.close();

            resultData.setText(s);

        } catch (FileNotFoundException ex) {
            Logger.getLogger(MyMatrixL_GUI.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(MyMatrixL_GUI.class.getName()).log(Level.SEVERE, null, ex);
        }        
    }

    public String getErrorData()
    {
        /*
            Se implementa un thread.sleep(), como tal no es lo ideal, pero funciona...
            se utilizó debido a que los archivos de texto tardan en actualizarse,
            entonces, si no espero el suficiente tiempo el programa leería una
            versión vieja del archivo de texto.
        */
        try {
            Thread.sleep(1750);
        } catch (InterruptedException ex) {
            Logger.getLogger(MyMatrixL_GUI.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        // Se leen los datos del archivo que almacena los errores
        try {
            BufferedReader br = new BufferedReader(new FileReader(route + "/myMatrixL_errors.txt"));

            String line = "";
            String s = "";

            while ((line = br.readLine()) != null)
            {
                s+= line + "\n";
            }

            if (br != null)
                br.close();
            return s;
            
        } catch (FileNotFoundException ex) {
            Logger.getLogger(MyMatrixL_GUI.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(MyMatrixL_GUI.class.getName()).log(Level.SEVERE, null, ex);
        }
        return "";
    }
    
    private void txtDataKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_txtDataKeyReleased
        
        /*
            Esta función se ejecuta cada vez que se presiona una tecla
        */

        /*
            En esta sección se obtiene la posición del cursor, tanto su columna
            como la línea en la que se encuentra, esto nos sirve para dos cosas,
            para desplegar gráficamente la ubicación del cursor, y para
            hacer unos ajustes de la ubicación del cursor cuando se quiere
            editar el textBox en una posición que no es la última.
        */ 
        int caretPos = txtData.getCaretPosition();
        int rowNum = (caretPos == 0) ? 1 : 0;
        for (int offset = caretPos; offset > 0;) {
            try {
                offset = Utilities.getRowStart(txtData, offset) - 1;
            } catch (BadLocationException ex) {
                Logger.getLogger(MyMatrixL_GUI.class.getName()).log(Level.SEVERE, null, ex);
            }
            rowNum++;
        }
        int colNum = 0;
        int offset;
        try {
            offset = Utilities.getRowStart(txtData, caretPos);
            colNum = caretPos - offset + 1;
        } catch (BadLocationException ex) {
            Logger.getLogger(MyMatrixL_GUI.class.getName()).log(Level.SEVERE, null, ex);
        }
        int initCursorPos = txtData.getCaretPosition();
        
        // Se almacena el text del TextBox en una variable y se elimina el 
        // contenido de este mismo, posteriormente se reescribe de manera resaltada
        String currentText = txtData.getText();
        txtData.setText("");

        
        // Se verifica si el cursor esta al final
        boolean isCursorAtEnd = false;
        int skipLine = (int) currentText.chars().filter(ch -> ch == '\n').count();
        if (initCursorPos == currentText.length() - skipLine )
        {
            isCursorAtEnd = true;
        }
                
        String[] brackets = {"[", "]", "{", "}", "(", ")"};
        String[] operators = {"+", "*", "-", "^", "="};
        String[] punctuationSym = {",", ";"};
        
        /*
            Se recorren todos los caracteres del texto a analizar
            en esta sección se resalta el texto dependiendo de ciertos parámetros
            la función "textToPane" va a agregando el texto al textBox
        */

        int i = 0;
        while (i < currentText.length())
        {
            char c = currentText.charAt(i);
            
            if (array_contains(operators, String.valueOf(c)))
            {
                appendToPane(txtData, String.valueOf(c), Color.RED);
            }
            else if (array_contains(brackets, String.valueOf(c)))
            {
                appendToPane(txtData, String.valueOf(c), Color.GREEN);
            }
            else if(array_contains(punctuationSym, String.valueOf(c)))
            {
                appendToPane(txtData, String.valueOf(c), Color.black);
            }

            else
            {
                if (i+4 < currentText.length() && "m".equals(String.valueOf(c)) && "a".equals(String.valueOf(currentText.charAt(i+1))) 
                        && "i".equals(String.valueOf(currentText.charAt(i+2))) && "n".equals(String.valueOf(currentText.charAt(i+3)))
                        && !Character.isDigit(currentText.charAt(i+4)) && !Character.isLetter(currentText.charAt(i+4)))
                {
                    appendToPane(txtData, "main", Color.BLUE);
                    i = i+3;
                }
                else if (i+3 < currentText.length() && "i".equals(String.valueOf(c)) && "n".equals(String.valueOf(currentText.charAt(i+1))) 
                        && "t".equals(String.valueOf(currentText.charAt(i+2))) 
                        && !Character.isDigit(currentText.charAt(i+3)) && !Character.isLetter(currentText.charAt(i+3)))
                {
                    appendToPane(txtData, "int", Color.BLUE);
                    i = i+2;
                }
                else if (i+5 < currentText.length() && "w".equals(String.valueOf(c)) && "r".equals(String.valueOf(currentText.charAt(i+1))) 
                        && "i".equals(String.valueOf(currentText.charAt(i+2))) && "t".equals(String.valueOf(currentText.charAt(i+3)))
                        && "e".equals(String.valueOf(currentText.charAt(i+4)))
                        && !Character.isDigit(currentText.charAt(i+5)) && !Character.isLetter(currentText.charAt(i+5)))
                {
                    appendToPane(txtData, "write", Color.BLUE);
                    i = i+4;
                }
                
                else if (i+6 < currentText.length() && "m".equals(String.valueOf(c)) && "a".equals(String.valueOf(currentText.charAt(i+1))) 
                        && "t".equals(String.valueOf(currentText.charAt(i+2))) && "r".equals(String.valueOf(currentText.charAt(i+3)))
                        && "i".equals(String.valueOf(currentText.charAt(i+4))) && "x".equals(String.valueOf(currentText.charAt(i+5)))
                        && !Character.isDigit(currentText.charAt(i+6)) && !Character.isLetter(currentText.charAt(i+6)))
                {
                    appendToPane(txtData, "matrix", Color.BLUE);
                    i = i+5;
                }
                
                else
                {
                    appendToPane(txtData, String.valueOf(c), Color.GRAY);
                }
            }
            i++;
        }
        
        cursorPositionText.setText("Line: " + rowNum + " Column: " + colNum);

        if (!isCursorAtEnd)
        {
            txtData.setCaretPosition(initCursorPos + rowNum  - 1);
        }
        
        /*
            El archivo matL (archivo a analizar y traducir) se actualiza cada 
            vez que se presiona una nueva tecla.
        */
        try {
            FileWriter matL_file = new FileWriter(route + "/matrixL_File.matL");

            matL_file.write(txtData.getText().replaceAll("\r", ""));
            
            matL_file.close();
        } catch (IOException ex) {
            Logger.getLogger(MyMatrixL_GUI.class.getName()).log(Level.SEVERE, null, ex);
        }
        
    }//GEN-LAST:event_txtDataKeyReleased

    // Esta función agrega texto al textBox (textPane)
    private void appendToPane(JTextPane tp, String msg, Color c)
    {
        
        StyleContext sc = StyleContext.getDefaultStyleContext();
        AttributeSet aset = sc.addAttribute(SimpleAttributeSet.EMPTY, StyleConstants.Foreground, c);

        aset = sc.addAttribute(aset, StyleConstants.FontFamily, "Lucida Console");
        aset = sc.addAttribute(aset, StyleConstants.Alignment, StyleConstants.ALIGN_JUSTIFIED);
        tp.setCharacterAttributes(aset, false);
        tp.replaceSelection(msg); 
    }
    
    private void txtDataPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_txtDataPropertyChange
        // TODO add your handling code here:

    }//GEN-LAST:event_txtDataPropertyChange

    private void txtDataCaretUpdate(javax.swing.event.CaretEvent evt) {//GEN-FIRST:event_txtDataCaretUpdate


    }//GEN-LAST:event_txtDataCaretUpdate

    // Esta función sirve para mostrar gráficamente la posicion del cursor
    private void txtDataMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_txtDataMouseClicked
        int caretPos = txtData.getCaretPosition();
        int rowNum = (caretPos == 0) ? 1 : 0;
        for (int offset = caretPos; offset > 0;) {
            try {
                offset = Utilities.getRowStart(txtData, offset) - 1;
            } catch (BadLocationException ex) {
                Logger.getLogger(MyMatrixL_GUI.class.getName()).log(Level.SEVERE, null, ex);
            }
            rowNum++;
        }

        int colNum = 0;
        int offset;
        try {
            offset = Utilities.getRowStart(txtData, caretPos);
            colNum = caretPos - offset + 1;
            System.out.println("Col: " + colNum);
        } catch (BadLocationException ex) {
            Logger.getLogger(MyMatrixL_GUI.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        cursorPositionText.setText("Line: " + rowNum + " Column: " + colNum);
    }//GEN-LAST:event_txtDataMouseClicked

    private void cursorPositionTextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cursorPositionTextActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_cursorPositionTextActionPerformed

    
    public boolean array_contains(String[] array, String word)
    {
        for (String token: array)
        {
            if (token.equals(word))
            {
                return true;
            }
        }
        return false;
    }

        
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(MyMatrixL_GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(MyMatrixL_GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(MyMatrixL_GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MyMatrixL_GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new MyMatrixL_GUI().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField cursorPositionText;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JButton openFileBtn;
    private javax.swing.JTextArea resultData;
    private javax.swing.JButton runBtn;
    private javax.swing.JButton saveFileBtn;
    private javax.swing.JTextPane txtData;
    // End of variables declaration//GEN-END:variables
}
